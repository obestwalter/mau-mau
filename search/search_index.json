{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mau Mau \u00b6 Play is the highest form of research -- Probably not Albert Einstein This project aims to be a learning tool, but this is a real application - not a toy example. The important difference to a \"real\" program is that the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft are kept at a minimum to enable you to explore the code as a nice little completely non-linear story. It came to life in a non-linear fashion and should also be read that way. Emphasis is put on pythonic ways to code and on using the power of the Open Source ecosystem. Features \u00b6 The game \u00b6 Complete rules of Mau Mau Two different strategies : Simple random strategy for a computer player Strategy that adds interactivity so a human can play against the computer Implementation and tools \u00b6 installable as command line tool runnable from the command line (created with fire ) simulation helpers to run multiple games and collect stats use of magic methods to create custom classes which behave like inbuilt data types logging with stdlib logging module developer task automation with tox orchestrating: automatic code formatting with black Static code analysis with flake8 running tests with pytest generation and deployment of documentation with MkDocs unifying running these locally and on CI with Travis and Appveyor version handling from source control with setuptools scm included Linux and Windows development environments via vagrant .","title":"Home"},{"location":"#mau-mau","text":"Play is the highest form of research -- Probably not Albert Einstein This project aims to be a learning tool, but this is a real application - not a toy example. The important difference to a \"real\" program is that the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft are kept at a minimum to enable you to explore the code as a nice little completely non-linear story. It came to life in a non-linear fashion and should also be read that way. Emphasis is put on pythonic ways to code and on using the power of the Open Source ecosystem.","title":"Mau Mau"},{"location":"#features","text":"","title":"Features"},{"location":"#the-game","text":"Complete rules of Mau Mau Two different strategies : Simple random strategy for a computer player Strategy that adds interactivity so a human can play against the computer","title":"The game"},{"location":"#implementation-and-tools","text":"installable as command line tool runnable from the command line (created with fire ) simulation helpers to run multiple games and collect stats use of magic methods to create custom classes which behave like inbuilt data types logging with stdlib logging module developer task automation with tox orchestrating: automatic code formatting with black Static code analysis with flake8 running tests with pytest generation and deployment of documentation with MkDocs unifying running these locally and on CI with Travis and Appveyor version handling from source control with setuptools scm included Linux and Windows development environments via vagrant .","title":"Implementation and tools"},{"location":"acknowledgements/","text":"Acknowledgements \u00b6 Thanks to the CodeCats and the Zeppelin University for giving me the chance to assist motivated students in learning to program. The logo is a c64-ified version of a playing card by Cobey Pile . Programming, template and markup languages \u00b6 Python Javascript HTML CSS Markdown ini YAML Jinja2 Tools \u00b6 IDE: PyCharm Automatic tests: pytest Static code analysis: Flake8 Source control: git Code collaboration: github Developer task automation: Tox Documentation: MkDocs with material theme Automatic version handling: Setuptools SCM Continuous Integration on Linux Travis CI Continuous Integration on Windows Appveyor Static code analysis as a service: quantifiedcode Markdown editing: Pycharm Markdown Navigator Generating diagrams: Gliffy Operating systems \u00b6 Ubuntu Linux Microsoft Windows 10","title":"Acknowlegements"},{"location":"acknowledgements/#acknowledgements","text":"Thanks to the CodeCats and the Zeppelin University for giving me the chance to assist motivated students in learning to program. The logo is a c64-ified version of a playing card by Cobey Pile .","title":"Acknowledgements"},{"location":"acknowledgements/#programming-template-and-markup-languages","text":"Python Javascript HTML CSS Markdown ini YAML Jinja2","title":"Programming, template and markup languages"},{"location":"acknowledgements/#tools","text":"IDE: PyCharm Automatic tests: pytest Static code analysis: Flake8 Source control: git Code collaboration: github Developer task automation: Tox Documentation: MkDocs with material theme Automatic version handling: Setuptools SCM Continuous Integration on Linux Travis CI Continuous Integration on Windows Appveyor Static code analysis as a service: quantifiedcode Markdown editing: Pycharm Markdown Navigator Generating diagrams: Gliffy","title":"Tools"},{"location":"acknowledgements/#operating-systems","text":"Ubuntu Linux Microsoft Windows 10","title":"Operating systems"},{"location":"_resources/","text":"Basis for Logo \u00b6 ... stolen from https://www.kickstarter.com/projects/45166364/8-bit-bicycle-playing-cards-0 (please let me know, if you don't like me remixing your stuff ... couldn't help myself) and mangled through http://c64.superdefault.com/ Queen of hearts Icon \u00b6 By en:User:Cburnett - Own work with Inkscape; queen icon taken from Image:Simple h q.svg, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1843180 Resources \u00b6 C64ify images: http://c64.superdefault.com/ Markdown extensions: https://github.com/waylan/Python-Markdown/wiki/Third-Party-Extensions","title":"Basis for Logo"},{"location":"_resources/#basis-for-logo","text":"... stolen from https://www.kickstarter.com/projects/45166364/8-bit-bicycle-playing-cards-0 (please let me know, if you don't like me remixing your stuff ... couldn't help myself) and mangled through http://c64.superdefault.com/","title":"Basis for Logo"},{"location":"_resources/#queen-of-hearts-icon","text":"By en:User:Cburnett - Own work with Inkscape; queen icon taken from Image:Simple h q.svg, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1843180","title":"Queen of hearts Icon"},{"location":"_resources/#resources","text":"C64ify images: http://c64.superdefault.com/ Markdown extensions: https://github.com/waylan/Python-Markdown/wiki/Third-Party-Extensions","title":"Resources"},{"location":"dev/ci/","text":"Continuous integration \u00b6 Travis CI \u00b6 Travis CI is a webservice that connects to your Github account and runs your tests for you. The configuration is in .travis.yml ( YAML format). As we're using tox already the integration with ci is very simple: just install and run tox on the build machine and we're done. The badge on top of the projects README.md shows the build status from Travis CI . This is a very simple setup. There are many more configuration options . Appveyor \u00b6 Appveyor is the pendant to run tests on Windows osses. The same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same: .appveyor.yml ( YAML format) The badge on top of the projects README.md shows the build status from Travis CI .","title":"Continuous intergration"},{"location":"dev/ci/#continuous-integration","text":"","title":"Continuous integration"},{"location":"dev/ci/#travis-ci","text":"Travis CI is a webservice that connects to your Github account and runs your tests for you. The configuration is in .travis.yml ( YAML format). As we're using tox already the integration with ci is very simple: just install and run tox on the build machine and we're done. The badge on top of the projects README.md shows the build status from Travis CI . This is a very simple setup. There are many more configuration options .","title":"Travis CI"},{"location":"dev/ci/#appveyor","text":"Appveyor is the pendant to run tests on Windows osses. The same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same: .appveyor.yml ( YAML format) The badge on top of the projects README.md shows the build status from Travis CI .","title":"Appveyor"},{"location":"dev/docs/","text":"Documentation building and hosting \u00b6 MkDocs and Github pages \u00b6 MkDocs \u00b6 The documentation is generated with MkDocs and it lives in docs/ . The configuration is in mkdocs.yml ( YAML format). Markdown is an easy to learn format that is the default on Github and Stack Overflow . It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation Sphinx and restructuredText might be better suited. Github pages \u00b6 Github offers the option to host the project documentation on Github Pages . MkDocs has an inbuilt deploy functionality to push the documentation there. The pages are hosted as project homepage on github.io . Working on the documentation \u00b6 When you work on the documentation you can start a local server: $ cd <path/to/your/clone> $ tox -e docs-auto This prepares an environment and runs mkdocs serve . You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate that you can use tox for automating and standardising all kinds of development tasks. The documentation is now served on localhost:8000 and changes are automatically detected and the website is reloaded. Tidy up the build in case of big changes or problems: $ tox -e docs-clean Deploying the documentation \u00b6 If you have push rights for the repository, you can deploy the current documentation with: $ cd <path/to/your/clone> $ tox -e docs-deploy","title":"Working on documentation"},{"location":"dev/docs/#documentation-building-and-hosting","text":"","title":"Documentation building and hosting"},{"location":"dev/docs/#mkdocs-and-github-pages","text":"","title":"MkDocs and Github pages"},{"location":"dev/docs/#mkdocs","text":"The documentation is generated with MkDocs and it lives in docs/ . The configuration is in mkdocs.yml ( YAML format). Markdown is an easy to learn format that is the default on Github and Stack Overflow . It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation Sphinx and restructuredText might be better suited.","title":"MkDocs"},{"location":"dev/docs/#github-pages","text":"Github offers the option to host the project documentation on Github Pages . MkDocs has an inbuilt deploy functionality to push the documentation there. The pages are hosted as project homepage on github.io .","title":"Github pages"},{"location":"dev/docs/#working-on-the-documentation","text":"When you work on the documentation you can start a local server: $ cd <path/to/your/clone> $ tox -e docs-auto This prepares an environment and runs mkdocs serve . You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate that you can use tox for automating and standardising all kinds of development tasks. The documentation is now served on localhost:8000 and changes are automatically detected and the website is reloaded. Tidy up the build in case of big changes or problems: $ tox -e docs-clean","title":"Working on the documentation"},{"location":"dev/docs/#deploying-the-documentation","text":"If you have push rights for the repository, you can deploy the current documentation with: $ cd <path/to/your/clone> $ tox -e docs-deploy","title":"Deploying the documentation"},{"location":"dev/getting-started/","text":"Getting started \u00b6 Note Please replace </path/to/your/clone> with the actual path of your mau-mau repository clone on your computer. To work on the code: Fork the repository Clone the repository to <path/to/your/clone> (wherever that is). ... and install the code as editable in a virtualenv : $ <activate your virtualenv> $ cd <path/to/your/clone> $ pip install -e '.[all]' The output looks like: Obtaining file:///</path/to/your/clone> Installing collected packages: mau-mau Running setup.py develop for mau-mau Successfully installed mau-mau Make sure it is installed as editable: $ pip freeze The output looks like (most packages removed from list): [...] -e git+git@github.com:obestwalter/mau-mau.git@e4031a17a5e08551317a321d7e74f9ca3b33e0b1#egg=mau_mau [...] win-unicode-console==0.4 The line starting with the -e indicates that mau-mau is installed as editable from github. Using vagrant \u00b6 The project comes with a configured Arch Linux box that can run mau-mau without you having to change anything on your computer (given you have vagrant and VirtualBox already installed. $ cd <path/to/your/clone> You need to be in your project folder to work with vagrant. $ vagrant up then enter the box ... $ vagrant ssh And do whatever you need to do for development and testing e.g. $ pip install -e . $ mau-mau play or $ tox","title":"Getting started"},{"location":"dev/getting-started/#getting-started","text":"Note Please replace </path/to/your/clone> with the actual path of your mau-mau repository clone on your computer. To work on the code: Fork the repository Clone the repository to <path/to/your/clone> (wherever that is). ... and install the code as editable in a virtualenv : $ <activate your virtualenv> $ cd <path/to/your/clone> $ pip install -e '.[all]' The output looks like: Obtaining file:///</path/to/your/clone> Installing collected packages: mau-mau Running setup.py develop for mau-mau Successfully installed mau-mau Make sure it is installed as editable: $ pip freeze The output looks like (most packages removed from list): [...] -e git+git@github.com:obestwalter/mau-mau.git@e4031a17a5e08551317a321d7e74f9ca3b33e0b1#egg=mau_mau [...] win-unicode-console==0.4 The line starting with the -e indicates that mau-mau is installed as editable from github.","title":"Getting started"},{"location":"dev/getting-started/#using-vagrant","text":"The project comes with a configured Arch Linux box that can run mau-mau without you having to change anything on your computer (given you have vagrant and VirtualBox already installed. $ cd <path/to/your/clone> You need to be in your project folder to work with vagrant. $ vagrant up then enter the box ... $ vagrant ssh And do whatever you need to do for development and testing e.g. $ pip install -e . $ mau-mau play or $ tox","title":"Using vagrant"},{"location":"dev/static-analysis/","text":"Static code analysis \u00b6 Flake8 \u00b6 Flake8 is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code. Run flake8 analysis: $ cd <path/to/your/clone> $ flake8 mau_mau/ tests/ --show-source If flake8 is happy it won't produce any output. If not, it looks ike this: mau_mau/play.py:39:80: E501 line too long (84 > 79 characters) #################################################################################### ^ mau_mau/play.py:41:1: E302 expected 2 blank lines, found 1 def main(): ^","title":"Static code analysis"},{"location":"dev/static-analysis/#static-code-analysis","text":"","title":"Static code analysis"},{"location":"dev/static-analysis/#flake8","text":"Flake8 is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code. Run flake8 analysis: $ cd <path/to/your/clone> $ flake8 mau_mau/ tests/ --show-source If flake8 is happy it won't produce any output. If not, it looks ike this: mau_mau/play.py:39:80: E501 line too long (84 > 79 characters) #################################################################################### ^ mau_mau/play.py:41:1: E302 expected 2 blank lines, found 1 def main(): ^","title":"Flake8"},{"location":"dev/tests/","text":"Automatic tests \u00b6 pytest is my tool of choice. There is also a standard library solution , which has too much API overhead for my taste and is by for not as convenient as pytest is. pytest does some very clever things to let you use the assertion statement directly and you get much better failure reports. It also has fixtures which makes it very easy to make test code very modular. This makes for much cleaner test code. Note The sources of the test modules are here: tests/ The ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt assert for writing tests. pytest (command line) \u00b6 pytest looks for modules with the pattern test_*.py downwards from your cwd . In those modules it looks for def test_* and class Test* . After collecting everything fitting those patterns it execute all test functions and reports back. $ cd </path/to/your/clone> $ pytest Example for a successful run: ========================== test session starts ========================== platform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 13 items tests/test_pile.py ..... tests/test_player.py ... tests/test_sim.py ..... ======================= 13 passed in 0.03 seconds ======================= Example for a not so successful run: ======================= test session starts ============================= platform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 35 items tests/test_concepts.py ................... tests/test_objects.py ..F.. tests/test_player.py ... tests/test_rules.py ... tests/test_sim.py ..... ======================== short test summary info ======================== FAIL tests/test_objects.py::test_non_empty_stock =============================== FAILURES ================================ _________________________ test_non_empty_stock __________________________ def test_non_empty_stock(): > assert not Stock([0]) E assert not Stock([0]) E + where Stock([0]) = Stock([0]) tests/test_objects.py:17: AssertionError ==================== 1 failed, 34 passed in 0.21 seconds ================ This test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the Stock class. If you pass a list when you create the class (like Stock([Card('Queen', '\u2660'), Card('10', '\u2660')]) ), you should not expect it to be empty afterwards. Automatically run tests on changes: \u00b6 If you want to take this one step further and have the tests being run automatically every time the code changes, you can: $ pip install pytest-watch $ cd </path/to/your/clone> $ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"' notify-send is how I can send desktop notifications from the commandline in my os ( Linux ). There are lots of ways to do this on every os - even Windows and Mac . pytest (PyCharm) \u00b6 Preparation \u00b6 The default testrunner in PyCharm is Unittest. You have to switch to pytest like so: * Find Action: default testrunner : set to pytest * accept offer to install it in your project virtualenv or do it yourself with pip install pytest Running tests \u00b6 Depending on where you are, you can run all tests or a part of them. The magic action is run context configuration . It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ... Focus in the editor, inside a specific test Focus in the editor on the line defining a class containing tests Focus in the Project Tool Window , choose the tests/ folder and ... all yields different results as which tests are run (and they are what you would intuitively expect). Doctests \u00b6 You can write simple examples that can double as tests directly in documentation strings. They are called doctests . You can run them directly from PyCharm as well. For an example in the code see concepts.py","title":"Automatic tests"},{"location":"dev/tests/#automatic-tests","text":"pytest is my tool of choice. There is also a standard library solution , which has too much API overhead for my taste and is by for not as convenient as pytest is. pytest does some very clever things to let you use the assertion statement directly and you get much better failure reports. It also has fixtures which makes it very easy to make test code very modular. This makes for much cleaner test code. Note The sources of the test modules are here: tests/ The ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt assert for writing tests.","title":"Automatic tests"},{"location":"dev/tests/#pytest-command-line","text":"pytest looks for modules with the pattern test_*.py downwards from your cwd . In those modules it looks for def test_* and class Test* . After collecting everything fitting those patterns it execute all test functions and reports back. $ cd </path/to/your/clone> $ pytest Example for a successful run: ========================== test session starts ========================== platform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 13 items tests/test_pile.py ..... tests/test_player.py ... tests/test_sim.py ..... ======================= 13 passed in 0.03 seconds ======================= Example for a not so successful run: ======================= test session starts ============================= platform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 35 items tests/test_concepts.py ................... tests/test_objects.py ..F.. tests/test_player.py ... tests/test_rules.py ... tests/test_sim.py ..... ======================== short test summary info ======================== FAIL tests/test_objects.py::test_non_empty_stock =============================== FAILURES ================================ _________________________ test_non_empty_stock __________________________ def test_non_empty_stock(): > assert not Stock([0]) E assert not Stock([0]) E + where Stock([0]) = Stock([0]) tests/test_objects.py:17: AssertionError ==================== 1 failed, 34 passed in 0.21 seconds ================ This test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the Stock class. If you pass a list when you create the class (like Stock([Card('Queen', '\u2660'), Card('10', '\u2660')]) ), you should not expect it to be empty afterwards.","title":"pytest (command line)"},{"location":"dev/tests/#automatically-run-tests-on-changes","text":"If you want to take this one step further and have the tests being run automatically every time the code changes, you can: $ pip install pytest-watch $ cd </path/to/your/clone> $ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"' notify-send is how I can send desktop notifications from the commandline in my os ( Linux ). There are lots of ways to do this on every os - even Windows and Mac .","title":"Automatically run tests on changes:"},{"location":"dev/tests/#pytest-pycharm","text":"","title":"pytest (PyCharm)"},{"location":"dev/tests/#preparation","text":"The default testrunner in PyCharm is Unittest. You have to switch to pytest like so: * Find Action: default testrunner : set to pytest * accept offer to install it in your project virtualenv or do it yourself with pip install pytest","title":"Preparation"},{"location":"dev/tests/#running-tests","text":"Depending on where you are, you can run all tests or a part of them. The magic action is run context configuration . It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ... Focus in the editor, inside a specific test Focus in the editor on the line defining a class containing tests Focus in the Project Tool Window , choose the tests/ folder and ... all yields different results as which tests are run (and they are what you would intuitively expect).","title":"Running tests"},{"location":"dev/tests/#doctests","text":"You can write simple examples that can double as tests directly in documentation strings. They are called doctests . You can run them directly from PyCharm as well. For an example in the code see concepts.py","title":"Doctests"},{"location":"dev/tox/","text":"tox - a developer frontend \u00b6 What? \u00b6 The name of the tox automation project derives from \"testing out of the box\". It aims to \"automate and standardize testing in Python\". Conceptually it is one level above pytest and serves as a command line frontend for running tests and automate all kinds of tasks around the project. It also acts as a frontend for Continuous Integration Systems to unify what you do locally and what happens in e.g. Jenkins or Travis CI. How? \u00b6 tox can build the package under test, create virtual environments for different Python interpreters, install dependencies and does whatever else is needed for test preparation. After setting the stage it runs the tests and outputs the results. This way you can also run the same tests for different interpreters if you support different version of Python like 2.7 and 3.4, etc. In this project we use it to run the tests and for building, developing and deploying the documentation. tox generated \"developer documentation\" \u00b6 Since tox 2.7 you can also add descriptions to the different environments to provide a custom \"developer documentation\" - to get this you type tox -av in the e.g. in mau-mau project and the output would be like: using tox.ini: /home/oliver/learn/mau-mau/tox.ini using tox-2.7.0 from /home/oliver/.virtualenvs/mau-mau/lib/python3.6/site-packages/tox/__init__.py default environments: static -> run static tests using flake8 tests -> run automatic tests using pytest additional environments: docs-auto -> run local server that serves and rebuilds documentation docs-clean -> remove the generated documentation docs-deploy -> deploy documentation to github hosting docs-deploy-force -> delete documentation online and deploy completely fresh If you want to work on the documentation you type tox -e docs-auto and off you go :) Examples for running tests \u00b6 Run static code analysis: $ cd </path/to/your/clone> $ tox -e static The output is like: static create: </path/to/your/clone>/.tox/static static installdeps: flake8 static develop-inst: </path/to/your/clone> static installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0 static runtests: PYTHONHASHSEED='3703953266' static runtests: commands[0] | flake8 </path/to/your/clone>/mau_mau </path/to/your/clone>/tests --show-source Command line usage: $ cd </path/to/your/clone> $ tox -e tests The output is like: tests develop-inst-nodeps: </path/to/your/clone> tests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1 tests runtests: PYTHONHASHSEED='2804594378' tests runtests: commands[0] | pytest </path/to/your/clone>/tests ============================= test session starts ============================= platform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 35 items tests/test_concepts.py ................... tests/test_objects.py ..... tests/test_player.py ... tests/test_rules.py ... tests/test_sim.py ..... ========================== 35 passed in 0.04 seconds ========================== ___________________________________ summary ___________________________________ tests: commands succeeded congratulations :) This is a very simple setup. There are many more configuration options Note Just running tox without parameters runs all the environments defined in envlist.","title":"Using Tox"},{"location":"dev/tox/#tox-a-developer-frontend","text":"","title":"tox - a developer frontend"},{"location":"dev/tox/#what","text":"The name of the tox automation project derives from \"testing out of the box\". It aims to \"automate and standardize testing in Python\". Conceptually it is one level above pytest and serves as a command line frontend for running tests and automate all kinds of tasks around the project. It also acts as a frontend for Continuous Integration Systems to unify what you do locally and what happens in e.g. Jenkins or Travis CI.","title":"What?"},{"location":"dev/tox/#how","text":"tox can build the package under test, create virtual environments for different Python interpreters, install dependencies and does whatever else is needed for test preparation. After setting the stage it runs the tests and outputs the results. This way you can also run the same tests for different interpreters if you support different version of Python like 2.7 and 3.4, etc. In this project we use it to run the tests and for building, developing and deploying the documentation.","title":"How?"},{"location":"dev/tox/#tox-generated-developer-documentation","text":"Since tox 2.7 you can also add descriptions to the different environments to provide a custom \"developer documentation\" - to get this you type tox -av in the e.g. in mau-mau project and the output would be like: using tox.ini: /home/oliver/learn/mau-mau/tox.ini using tox-2.7.0 from /home/oliver/.virtualenvs/mau-mau/lib/python3.6/site-packages/tox/__init__.py default environments: static -> run static tests using flake8 tests -> run automatic tests using pytest additional environments: docs-auto -> run local server that serves and rebuilds documentation docs-clean -> remove the generated documentation docs-deploy -> deploy documentation to github hosting docs-deploy-force -> delete documentation online and deploy completely fresh If you want to work on the documentation you type tox -e docs-auto and off you go :)","title":"tox generated \"developer documentation\""},{"location":"dev/tox/#examples-for-running-tests","text":"Run static code analysis: $ cd </path/to/your/clone> $ tox -e static The output is like: static create: </path/to/your/clone>/.tox/static static installdeps: flake8 static develop-inst: </path/to/your/clone> static installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0 static runtests: PYTHONHASHSEED='3703953266' static runtests: commands[0] | flake8 </path/to/your/clone>/mau_mau </path/to/your/clone>/tests --show-source Command line usage: $ cd </path/to/your/clone> $ tox -e tests The output is like: tests develop-inst-nodeps: </path/to/your/clone> tests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1 tests runtests: PYTHONHASHSEED='2804594378' tests runtests: commands[0] | pytest </path/to/your/clone>/tests ============================= test session starts ============================= platform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1 rootdir: </path/to/your/clone>, inifile: tox.ini collected 35 items tests/test_concepts.py ................... tests/test_objects.py ..... tests/test_player.py ... tests/test_rules.py ... tests/test_sim.py ..... ========================== 35 passed in 0.04 seconds ========================== ___________________________________ summary ___________________________________ tests: commands succeeded congratulations :) This is a very simple setup. There are many more configuration options Note Just running tox without parameters runs all the environments defined in envlist.","title":"Examples for running tests"},{"location":"guide/installation/","text":"Installation \u00b6 Which Python version should I use? \u00b6 Short version: Python 2.x is legacy, Python 3.x is the present and future of the language and 3.6 is the new hotness and I won't do it below that. -- Should I use Python 2 or Python 3 for my development activity? ... nuff said. To be more exact: Python 3.6 \u00b6 There are a lot of great additions in Python 3.6 - most of them backwards compatible, but I will use at least one backwards incompatible feature in this project: f-strings - because I can :D Note It might already be installed. Type python on the commandline and see if a Python REPL opens and which version it reports. If the standard python interpreter is still Python2 on your system, try typing python3 instead and see if you are lucky. If not get it here: Python3 . [In a virtualenv] \u00b6 Note The installation of this package in a virtualenv is is not necessary but recommended. It is worth learning to work with virtualenvs as early as possible anyway. You should really install this in a virtualenv . This should work out of the box. If not, you might be on Linux and are bitten by this . sudo apt-get install python3-pip should solve the problem - otherwise have a look at the pip documentation . $ python3.6 -m venv mau-mau-env Activation of virtualenvs is sadly still one of the things that is not os independent, so you will have to look here how to do that in your os. The most common cases are: $ source mau-mau-env/bin/activate # most linux shells $ mau-mau-env\\Scripts\\activate.bat # Windows cmd.exe Deactivate with: $ deactivate ... from Github \u00b6 Install the latest code directly from github by typing on the command line: $ pip install \"git+https://github.com/obestwalter/mau-mau.git#egg=mau-mau\" To install a specific version just replace master with the version you want to install (e.g. 1.1.0 ). The different versions can be seen in the release section of a Github project. ... from .zip file \u00b6 On the releases page you can download zip archives and install them by typing on the command line: $ pip install </path/to/downloaded/zip/archive> ... from PyPI \u00b6 This is not implemented This would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented here ) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software. If mau-mau would be uploaded to PyPI, it could be installed by simply typing: $ pip install mau-mau","title":"Installation"},{"location":"guide/installation/#installation","text":"","title":"Installation"},{"location":"guide/installation/#which-python-version-should-i-use","text":"Short version: Python 2.x is legacy, Python 3.x is the present and future of the language and 3.6 is the new hotness and I won't do it below that. -- Should I use Python 2 or Python 3 for my development activity? ... nuff said.","title":"Which Python version should I use?"},{"location":"guide/installation/#to-be-more-exact-python-36","text":"There are a lot of great additions in Python 3.6 - most of them backwards compatible, but I will use at least one backwards incompatible feature in this project: f-strings - because I can :D Note It might already be installed. Type python on the commandline and see if a Python REPL opens and which version it reports. If the standard python interpreter is still Python2 on your system, try typing python3 instead and see if you are lucky. If not get it here: Python3 .","title":"To be more exact: Python 3.6"},{"location":"guide/installation/#in-a-virtualenv","text":"Note The installation of this package in a virtualenv is is not necessary but recommended. It is worth learning to work with virtualenvs as early as possible anyway. You should really install this in a virtualenv . This should work out of the box. If not, you might be on Linux and are bitten by this . sudo apt-get install python3-pip should solve the problem - otherwise have a look at the pip documentation . $ python3.6 -m venv mau-mau-env Activation of virtualenvs is sadly still one of the things that is not os independent, so you will have to look here how to do that in your os. The most common cases are: $ source mau-mau-env/bin/activate # most linux shells $ mau-mau-env\\Scripts\\activate.bat # Windows cmd.exe Deactivate with: $ deactivate","title":"[In a virtualenv]"},{"location":"guide/installation/#from-github","text":"Install the latest code directly from github by typing on the command line: $ pip install \"git+https://github.com/obestwalter/mau-mau.git#egg=mau-mau\" To install a specific version just replace master with the version you want to install (e.g. 1.1.0 ). The different versions can be seen in the release section of a Github project.","title":"... from Github"},{"location":"guide/installation/#from-zip-file","text":"On the releases page you can download zip archives and install them by typing on the command line: $ pip install </path/to/downloaded/zip/archive>","title":"... from .zip file"},{"location":"guide/installation/#from-pypi","text":"This is not implemented This would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented here ) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software. If mau-mau would be uploaded to PyPI, it could be installed by simply typing: $ pip install mau-mau","title":"... from PyPI"},{"location":"guide/rules/","text":"Rules \u00b6 Basics \u00b6 The game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards. One can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack. -- Wikipedia - Mau Mau Common additions \u00b6 In addition, the three most common rules are implemented: If an eight is played, the next player is skipped If a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on). A Jack can can be put on anything and the player who played it can ask for a different suite to be played","title":"Rules of Mau Mau"},{"location":"guide/rules/#rules","text":"","title":"Rules"},{"location":"guide/rules/#basics","text":"The game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards. One can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack. -- Wikipedia - Mau Mau","title":"Basics"},{"location":"guide/rules/#common-additions","text":"In addition, the three most common rules are implemented: If an eight is played, the next player is skipped If a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on). A Jack can can be put on anything and the player who played it can ask for a different suite to be played","title":"Common additions"},{"location":"guide/usage/","text":"Usage \u00b6 Command line access \u00b6 After installation you have two additional commands in your virtualenv: mau-mau and mau-mau-stats . The cli (command line interface) is automatically generated with a fun little library called python-fire . The default behaviour for our mau-mau is to show the usage info with the available commands: Play or simulate a single game \u00b6 $ mau-mau Type: Cli String form: <mau_mau.play.cli.<locals>.Cli object at 0x7f7fa3b3e5c0> Usage: mau-mau mau-mau play mau-mau sim You can then ask for specific help for commands (note the -- to separate the command from the fire arg --help ), e.g: $ mau-mau play -- --help Type: method String form: <bound method cli.<locals>.Cli.play of <mau_mau.play.cli.<locals>.Cli object at 0x7f92d2c46e80>> File: /home/ob/do/mau-mau/src/mau_mau/play.py Line: 42 Docstring: Play a game against two computer players. If one of the players' names is 'human' it will be interactive. Usage: mau-mau play [PLAYERS] mau-mau play [--players PLAYERS] You can start a game that you play against two computer players by calling mau-mau play --players John,Terry,human The fire library accomplishes this using introspection of the code to generate arguments and documentation. A more standard approach would be argparse which is provided in the standard library already. Simulate a game \u00b6 $ mau-mau sim The output could be: mau_mau.subjects 28 invite : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None) mau_mau.subjects 100 draw : Player 1 <- Card('10', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('8', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('Ace', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('Ace', '\u2660') mau_mau.subjects 100 draw : Player 1 <- Card('9', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('8', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('7', '\u2663') mau_mau.subjects 100 draw : Player 2 <- Card('Queen', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('7', '\u2660') mau_mau.subjects 100 draw : Player 2 <- Card('8', '\u2666') mau_mau.subjects 100 draw : Player 3 <- Card('10', '\u2665') mau_mau.subjects 100 draw : Player 3 <- Card('9', '\u2666') mau_mau.subjects 100 draw : Player 3 <- Card('Jack', '\u2660') mau_mau.subjects 100 draw : Player 3 <- Card('Jack', '\u2663') mau_mau.subjects 100 draw : Player 3 <- Card('King', '\u2665') mau_mau.play 28 setup_game : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))])) mau_mau.concepts 25 next_turn : -------------------- turn 1 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Queen', '\u2663') mau_mau.concepts 27 next_turn : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Queen', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('10', '\u2663') [--- SNIP ---] mau_mau.concepts 25 next_turn : -------------------- turn 27 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.strategy 65 _play : nothing to play mau_mau.subjects 100 draw : Player 3 <- Card('8', '\u2660') mau_mau.concepts 25 next_turn : -------------------- turn 28 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.strategy 65 _play : nothing to play mau_mau.subjects 100 draw : Player 1 <- Card('Queen', '\u2660') mau_mau.concepts 25 next_turn : -------------------- turn 29 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 2', Hand([Card('King', '\u2663')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('King', '\u2663') root 21 play_simple_game : And the winner is Player 2 Play against the computer \u00b6 Play interactive game (and know and see everything ...): $ mau-mau play The output could be: mau_mau.subjects 28 invite : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None) mau_mau.subjects 100 draw : Eric <- Card('Queen', '\u2660') mau_mau.subjects 100 draw : Eric <- Card('10', '\u2660') mau_mau.subjects 100 draw : Eric <- Card('Queen', '\u2663') mau_mau.subjects 100 draw : Eric <- Card('8', '\u2666') mau_mau.subjects 100 draw : Eric <- Card('7', '\u2660') mau_mau.subjects 100 draw : John <- Card('9', '\u2660') mau_mau.subjects 100 draw : John <- Card('Ace', '\u2660') mau_mau.subjects 100 draw : John <- Card('10', '\u2666') mau_mau.subjects 100 draw : John <- Card('Ace', '\u2663') mau_mau.subjects 100 draw : John <- Card('8', '\u2665') mau_mau.subjects 100 draw : human <- Card('Ace', '\u2666') mau_mau.subjects 100 draw : human <- Card('7', '\u2666') mau_mau.subjects 100 draw : human <- Card('King', '\u2665') mau_mau.subjects 100 draw : human <- Card('9', '\u2666') mau_mau.subjects 100 draw : human <- Card('King', '\u2660') mau_mau.play 28 setup_game : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))])) mau_mau.concepts 25 next_turn : -------------------- turn 1 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2663') mau_mau.concepts 27 next_turn : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Queen', '\u2663') mau_mau.concepts 25 next_turn : -------------------- turn 2 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Queen', '\u2663') mau_mau.concepts 27 next_turn : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Queen', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Ace', '\u2663') [---- SNIP ----] mau_mau.concepts 25 next_turn : -------------------- turn 22 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('8', '\u2665') mau_mau.concepts 27 next_turn : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule SkipNextPlayer on Card('8', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('10', '\u2665') mau_mau.concepts 25 next_turn : -------------------- turn 23 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('10', '\u2665') mau_mau.concepts 27 next_turn : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('10', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Ace', '\u2665') mau_mau.concepts 25 next_turn : -------------------- turn 24 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Ace', '\u2665') mau_mau.concepts 27 next_turn : Player('human', Hand([Card('King', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Ace', '\u2665') mau_mau.strategy 56 _play : find card to play choose card to play. 1 -> Card('King', '\u2665') | 1 mau_mau.subjects 103 put : play Card('King', '\u2665') root 27 play_interactive_game: And the winner is human Collect statistics \u00b6 $ mau-mau-stats turns The output could be: mau_mau.stats 35 _simulate_games : players: 3; 1000 reps mau_mau.stats 12 turns : mean turns played: 34.097 Input: $ mau-mau-stats winners The output could be: mau_mau.stats 35 _simulate_games : players: ('Eric', 'Terry', 'John'); 1000 reps mau_mau.stats 21 distribution : winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328} Input: $ mau-mau-stats durations The output could be: mau_mau.stats 31 time_durations : it takes 0.643 seconds to play 1000 games","title":"Command line access"},{"location":"guide/usage/#usage","text":"","title":"Usage"},{"location":"guide/usage/#command-line-access","text":"After installation you have two additional commands in your virtualenv: mau-mau and mau-mau-stats . The cli (command line interface) is automatically generated with a fun little library called python-fire . The default behaviour for our mau-mau is to show the usage info with the available commands:","title":"Command line access"},{"location":"guide/usage/#play-or-simulate-a-single-game","text":"$ mau-mau Type: Cli String form: <mau_mau.play.cli.<locals>.Cli object at 0x7f7fa3b3e5c0> Usage: mau-mau mau-mau play mau-mau sim You can then ask for specific help for commands (note the -- to separate the command from the fire arg --help ), e.g: $ mau-mau play -- --help Type: method String form: <bound method cli.<locals>.Cli.play of <mau_mau.play.cli.<locals>.Cli object at 0x7f92d2c46e80>> File: /home/ob/do/mau-mau/src/mau_mau/play.py Line: 42 Docstring: Play a game against two computer players. If one of the players' names is 'human' it will be interactive. Usage: mau-mau play [PLAYERS] mau-mau play [--players PLAYERS] You can start a game that you play against two computer players by calling mau-mau play --players John,Terry,human The fire library accomplishes this using introspection of the code to generate arguments and documentation. A more standard approach would be argparse which is provided in the standard library already.","title":"Play or simulate a single game"},{"location":"guide/usage/#simulate-a-game","text":"$ mau-mau sim The output could be: mau_mau.subjects 28 invite : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None) mau_mau.subjects 100 draw : Player 1 <- Card('10', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('8', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('Ace', '\u2663') mau_mau.subjects 100 draw : Player 1 <- Card('Ace', '\u2660') mau_mau.subjects 100 draw : Player 1 <- Card('9', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('8', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('7', '\u2663') mau_mau.subjects 100 draw : Player 2 <- Card('Queen', '\u2665') mau_mau.subjects 100 draw : Player 2 <- Card('7', '\u2660') mau_mau.subjects 100 draw : Player 2 <- Card('8', '\u2666') mau_mau.subjects 100 draw : Player 3 <- Card('10', '\u2665') mau_mau.subjects 100 draw : Player 3 <- Card('9', '\u2666') mau_mau.subjects 100 draw : Player 3 <- Card('Jack', '\u2660') mau_mau.subjects 100 draw : Player 3 <- Card('Jack', '\u2663') mau_mau.subjects 100 draw : Player 3 <- Card('King', '\u2665') mau_mau.play 28 setup_game : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))])) mau_mau.concepts 25 next_turn : -------------------- turn 1 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Queen', '\u2663') mau_mau.concepts 27 next_turn : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Queen', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('10', '\u2663') [--- SNIP ---] mau_mau.concepts 25 next_turn : -------------------- turn 27 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.strategy 65 _play : nothing to play mau_mau.subjects 100 draw : Player 3 <- Card('8', '\u2660') mau_mau.concepts 25 next_turn : -------------------- turn 28 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.strategy 65 _play : nothing to play mau_mau.subjects 100 draw : Player 1 <- Card('Queen', '\u2660') mau_mau.concepts 25 next_turn : -------------------- turn 29 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2665') mau_mau.concepts 27 next_turn : Player('Player 2', Hand([Card('King', '\u2663')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('King', '\u2663') root 21 play_simple_game : And the winner is Player 2","title":"Simulate a game"},{"location":"guide/usage/#play-against-the-computer","text":"Play interactive game (and know and see everything ...): $ mau-mau play The output could be: mau_mau.subjects 28 invite : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None) mau_mau.subjects 100 draw : Eric <- Card('Queen', '\u2660') mau_mau.subjects 100 draw : Eric <- Card('10', '\u2660') mau_mau.subjects 100 draw : Eric <- Card('Queen', '\u2663') mau_mau.subjects 100 draw : Eric <- Card('8', '\u2666') mau_mau.subjects 100 draw : Eric <- Card('7', '\u2660') mau_mau.subjects 100 draw : John <- Card('9', '\u2660') mau_mau.subjects 100 draw : John <- Card('Ace', '\u2660') mau_mau.subjects 100 draw : John <- Card('10', '\u2666') mau_mau.subjects 100 draw : John <- Card('Ace', '\u2663') mau_mau.subjects 100 draw : John <- Card('8', '\u2665') mau_mau.subjects 100 draw : human <- Card('Ace', '\u2666') mau_mau.subjects 100 draw : human <- Card('7', '\u2666') mau_mau.subjects 100 draw : human <- Card('King', '\u2665') mau_mau.subjects 100 draw : human <- Card('9', '\u2666') mau_mau.subjects 100 draw : human <- Card('King', '\u2660') mau_mau.play 28 setup_game : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))])) mau_mau.concepts 25 next_turn : -------------------- turn 1 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Jack', '\u2663') mau_mau.concepts 27 next_turn : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up mau_mau.strategy 17 play : encountered rule DemandWantedSuit on Card('Jack', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Queen', '\u2663') mau_mau.concepts 25 next_turn : -------------------- turn 2 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Queen', '\u2663') mau_mau.concepts 27 next_turn : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Queen', '\u2663') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Ace', '\u2663') [---- SNIP ----] mau_mau.concepts 25 next_turn : -------------------- turn 22 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('8', '\u2665') mau_mau.concepts 27 next_turn : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule SkipNextPlayer on Card('8', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('10', '\u2665') mau_mau.concepts 25 next_turn : -------------------- turn 23 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('10', '\u2665') mau_mau.concepts 27 next_turn : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('10', '\u2665') mau_mau.strategy 56 _play : find card to play mau_mau.subjects 103 put : play Card('Ace', '\u2665') mau_mau.concepts 25 next_turn : -------------------- turn 24 -------------------- mau_mau.concepts 26 next_turn : upcard: Card('Ace', '\u2665') mau_mau.concepts 27 next_turn : Player('human', Hand([Card('King', '\u2665')])) is up mau_mau.strategy 17 play : encountered rule BasicRule on Card('Ace', '\u2665') mau_mau.strategy 56 _play : find card to play choose card to play. 1 -> Card('King', '\u2665') | 1 mau_mau.subjects 103 put : play Card('King', '\u2665') root 27 play_interactive_game: And the winner is human","title":"Play against the computer"},{"location":"guide/usage/#collect-statistics","text":"$ mau-mau-stats turns The output could be: mau_mau.stats 35 _simulate_games : players: 3; 1000 reps mau_mau.stats 12 turns : mean turns played: 34.097 Input: $ mau-mau-stats winners The output could be: mau_mau.stats 35 _simulate_games : players: ('Eric', 'Terry', 'John'); 1000 reps mau_mau.stats 21 distribution : winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328} Input: $ mau-mau-stats durations The output could be: mau_mau.stats 31 time_durations : it takes 0.643 seconds to play 1000 games","title":"Collect statistics"},{"location":"implementation/explore/","text":"Explore the repository \u00b6 To explore the code repository it is best if you install the sources as editable . This means you can use the application as if it were installed normally but you can change the code and experiment. play.py \u00b6 Start exploring here The overall plot of the Mau Mau story can be found here. This is the entry point for starting to explore the actual application. It is written in an imperative way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops ( for ... in or while ) and conditioned branches ( if ... then ... else ). These are the basic control flow constructs Python has. There are a few more, but not many. Behold! The whole program in 6 lines! def play_game(gameRules, playerSeed): game = setup_game(gameRules, playerSeed) while not game.over: player = game.next_turn() player.play(game.table) return game This is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined. 6 lines of code including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the functions and classes used in the play_game function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program. Modules defining the classes \u00b6 These look pretty different from game.py and they are. Here is where the object oriented part of the story kicks in. If game.py contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact. concepts.py \u00b6 Classes that stand conceptually above the objects and subjects. objects.py and subjects.py \u00b6 I know .. in Python everything is an object, so this would be meaningless. This is also not subject oriented programming . These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects. rules.py \u00b6 This contains the classes that implement the rules of Mau Mau. Start reading with the MauMau class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a 7, the number of draws have to accumulate). strategies.py : How to play \u00b6 Classes that implement different player behaviours. Note A player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table. BasicStrategy \u00b6 Player plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of. This can be extended upon to implement \"real\" strategies. HumanStrategy \u00b6 Mainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer ( mau-mau human ). The impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. -- Tony Hoare ... you have been warned. sim.py : simulate series of games and create statistics \u00b6 Contains functions to run the game simulations and collect statistics. See usage examples Peripherals \u00b6 Note These files are not part of the actual software but are still vital for helping with development, installation, testing, etc. -- this makes all that tedious stuff you need when writing software less ... tedious. setup.py : Make program installable \u00b6 This module is what is being called, when the package is installed via pip or with python3 setup.py . This is the standard way of doing it in the Python ecosystem and it is documented here . tox.ini : Developer task automation \u00b6 This INI file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also the developer documentation for this tox.ini. .travis.yml and appveyor.yml : CI for different versions and osses \u00b6 See documentation about CI mkdocs.yml : Documentation configuration \u00b6 See the documentation for the documentation (I'm not kidding ...). Vagrantfile \u00b6 To start a VirtualBox with Linux or Windows prepared for development.","title":"Explore the code"},{"location":"implementation/explore/#explore-the-repository","text":"To explore the code repository it is best if you install the sources as editable . This means you can use the application as if it were installed normally but you can change the code and experiment.","title":"Explore the repository"},{"location":"implementation/explore/#playpy","text":"Start exploring here The overall plot of the Mau Mau story can be found here. This is the entry point for starting to explore the actual application. It is written in an imperative way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops ( for ... in or while ) and conditioned branches ( if ... then ... else ). These are the basic control flow constructs Python has. There are a few more, but not many. Behold! The whole program in 6 lines! def play_game(gameRules, playerSeed): game = setup_game(gameRules, playerSeed) while not game.over: player = game.next_turn() player.play(game.table) return game This is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined. 6 lines of code including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the functions and classes used in the play_game function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program.","title":"play.py"},{"location":"implementation/explore/#modules-defining-the-classes","text":"These look pretty different from game.py and they are. Here is where the object oriented part of the story kicks in. If game.py contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact.","title":"Modules defining the classes"},{"location":"implementation/explore/#conceptspy","text":"Classes that stand conceptually above the objects and subjects.","title":"concepts.py"},{"location":"implementation/explore/#objectspy-and-subjectspy","text":"I know .. in Python everything is an object, so this would be meaningless. This is also not subject oriented programming . These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects.","title":"objects.py and subjects.py"},{"location":"implementation/explore/#rulespy","text":"This contains the classes that implement the rules of Mau Mau. Start reading with the MauMau class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a 7, the number of draws have to accumulate).","title":"rules.py"},{"location":"implementation/explore/#strategiespy-how-to-play","text":"Classes that implement different player behaviours. Note A player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table.","title":"strategies.py: How to play"},{"location":"implementation/explore/#basicstrategy","text":"Player plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of. This can be extended upon to implement \"real\" strategies.","title":"BasicStrategy"},{"location":"implementation/explore/#humanstrategy","text":"Mainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer ( mau-mau human ). The impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. -- Tony Hoare ... you have been warned.","title":"HumanStrategy"},{"location":"implementation/explore/#simpy-simulate-series-of-games-and-create-statistics","text":"Contains functions to run the game simulations and collect statistics. See usage examples","title":"sim.py: simulate series of games and create statistics"},{"location":"implementation/explore/#peripherals","text":"Note These files are not part of the actual software but are still vital for helping with development, installation, testing, etc. -- this makes all that tedious stuff you need when writing software less ... tedious.","title":"Peripherals"},{"location":"implementation/explore/#setuppy-make-program-installable","text":"This module is what is being called, when the package is installed via pip or with python3 setup.py . This is the standard way of doing it in the Python ecosystem and it is documented here .","title":"setup.py: Make program installable"},{"location":"implementation/explore/#toxini-developer-task-automation","text":"This INI file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also the developer documentation for this tox.ini.","title":"tox.ini: Developer task automation"},{"location":"implementation/explore/#travisyml-and-appveyoryml-ci-for-different-versions-and-osses","text":"See documentation about CI","title":".travis.yml and appveyor.yml: CI for different versions and osses"},{"location":"implementation/explore/#mkdocsyml-documentation-configuration","text":"See the documentation for the documentation (I'm not kidding ...).","title":"mkdocs.yml: Documentation configuration"},{"location":"implementation/explore/#vagrantfile","text":"To start a VirtualBox with Linux or Windows prepared for development.","title":"Vagrantfile"},{"location":"implementation/ooommm/","text":"OOOMMM \u00b6 Obvious Object Oriented Mau Mau Modelling \u00b6 Switching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods, you have a basic description of object oriented programming. Object-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions. -- Bertrand Meyer - Object-Oriented Software Construction That's all very ... abstract, isn't it? Yes it is! Meyer goes on: Once you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency? What does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages. High level view \u00b6 One koan in the Zen of Python says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious. The image shows all the important elements of the simulation. Note Objects used in the program are marked like this , functions that describe (inter)actions are marked like this ). The game comprises two phases. We could call them \"setup\" and \"play\". Setup: The players are invited to a game at the table . A deck of cards is shuffled . The same amount of cards is dealt to the players to form their hand . One card - the upcard - is drawn from the stock and placed face up on the table . The remaining cards are piled face down on the table and form the stock . Now all is in place to play the game . Play: The players play in turns . They choose a card that is playable with the upcard according to the rules (same suit or same value and special rules ) and place it on the table . The played card is the new upcard and the old upcard is now part of the waste . Now the next player is up. If a player can't find a card to play, they have to draw one from the stock and the next player is up. If the stock is empty , the waste cards are shuffled to form the new stock . The game is over and the winner is found as soon as one player plays the last card of their hand . Easy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch Kurt Vonneguts short talk about the shape of stories and transfer your insights into thinking about abstract program code and its concrete execution :) The modelling problem we have here is ideal for creating custom data structures (which classes are), so we will model the game flow using custom Python classes that interact in the way described above.","title":"OOOMMM"},{"location":"implementation/ooommm/#ooommm","text":"","title":"OOOMMM"},{"location":"implementation/ooommm/#obvious-object-oriented-mau-mau-modelling","text":"Switching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods, you have a basic description of object oriented programming. Object-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions. -- Bertrand Meyer - Object-Oriented Software Construction That's all very ... abstract, isn't it? Yes it is! Meyer goes on: Once you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency? What does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages.","title":"Obvious Object Oriented Mau Mau Modelling"},{"location":"implementation/ooommm/#high-level-view","text":"One koan in the Zen of Python says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious. The image shows all the important elements of the simulation. Note Objects used in the program are marked like this , functions that describe (inter)actions are marked like this ). The game comprises two phases. We could call them \"setup\" and \"play\". Setup: The players are invited to a game at the table . A deck of cards is shuffled . The same amount of cards is dealt to the players to form their hand . One card - the upcard - is drawn from the stock and placed face up on the table . The remaining cards are piled face down on the table and form the stock . Now all is in place to play the game . Play: The players play in turns . They choose a card that is playable with the upcard according to the rules (same suit or same value and special rules ) and place it on the table . The played card is the new upcard and the old upcard is now part of the waste . Now the next player is up. If a player can't find a card to play, they have to draw one from the stock and the next player is up. If the stock is empty , the waste cards are shuffled to form the new stock . The game is over and the winner is found as soon as one player plays the last card of their hand . Easy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch Kurt Vonneguts short talk about the shape of stories and transfer your insights into thinking about abstract program code and its concrete execution :) The modelling problem we have here is ideal for creating custom data structures (which classes are), so we will model the game flow using custom Python classes that interact in the way described above.","title":"High level view"},{"location":"implementation/remarks/","text":"Remarks \u00b6 Significant whitespace \u00b6 Python is a language where space matters ... meaning units of code (blocks, function bodies, etc.) are delimited by a colon ( : ) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It indents the code automatically after ending a line with a colon. It also lets you indent and dedent entire blocks of code that are marked by pressing the Tab key and outdents them when pressing Shift + Tab . See also: code layout in PEP8. Example: def my_super_function(): print(\"I am indented with 4 spaces.\") print(\"Me too! We both belong to the function!\") print(\"I am not inside the function block anymore :(\") for currentElement in range(5): print(currentElement) print(\"I also belong to the loop block\") print(\"I don't belong to the loop block anymore\") Everything is an object \u00b6 Everything. Even functions, classes, modules and files. Everything. In this Python Online Tutor example you can see how really, really everything in a running Python program is an object. Passing by assignment \u00b6 Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se. -- How do I write a function with output parameters (call by reference)? The way passing data to functions work in Python is quite specific , so it is important that you are aware of it and understand it. Walk through this example in the tutor to visualise what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects. Changing the state of an object that is not returned explicitly is called a side effect . Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might lose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python. Magic methods (protocols) \u00b6 Those __something__() thingies might look scary for the uninitiated, but you will love them, once you have grasped the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations. Object representation ( __repr__ ) \u00b6 If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value -- Python docs In this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done correctly, this also works when using inheritance (see Stock and Waste ). This could also be useful: reprlib helps making better representations . Make your own objects behave like built in data types \u00b6 Let an object have a length ( __len__ ) and a concept of being True or False depending on having a length > 0 or not. Make an object iterable ( __iter__ ) . Other uses of special object attributes \u00b6 All objects have a name ( __name__ ) The name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program: Set the name of the logger object to get information from where the log was written If a module is started directly it has the special name __main__ - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the canonic way to do this. More resources about magic methods Python docs A Guide to Python's Magic Methods (original site went down sadly) Assertions \u00b6 What can be asserted without evidence can be dismissed without evidence. -- Christopher Hitchens To assert something means \"to state or express positively\". Assertions are regarded as important enough in Python that assert is a statement (since Python 3 even print is not important enough to be a statement). assert evaluates an expression and raises an AssertionError if the result of the evaluation is False (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is truthy if evaluated as bool . def spam(someObject): assert someObject, f\"Hey! {someObject} is not what I want!\" print(someObject) spam([1, 2]) spam([]) The assert in the spam function makes sure that the argument passed evaluates to True before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback. This is a good way to make sure that your program crashes early if the preconditions are not what you expect them. It's like making sure there is a chair there before you sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science. Look for uses of the assert statement in the code to get an idea how it might be used. Logging \u00b6 Python has an easy-to-use and convenient logging module included. There is no reason why beginners shouldn't learn to use that right away. This is better than cluttering the code with calls to print . With logging you have the possibility to use different log levels and adjust the output when debugging problems. You can set the level to logging.DEBUG to see the full story or even disable it when running thousands of simulations, where logging would slow the program down. We use a simple format and the convenience function to initialise the logger to write to the terminal with a certain level.","title":"Remarks"},{"location":"implementation/remarks/#remarks","text":"","title":"Remarks"},{"location":"implementation/remarks/#significant-whitespace","text":"Python is a language where space matters ... meaning units of code (blocks, function bodies, etc.) are delimited by a colon ( : ) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It indents the code automatically after ending a line with a colon. It also lets you indent and dedent entire blocks of code that are marked by pressing the Tab key and outdents them when pressing Shift + Tab . See also: code layout in PEP8. Example: def my_super_function(): print(\"I am indented with 4 spaces.\") print(\"Me too! We both belong to the function!\") print(\"I am not inside the function block anymore :(\") for currentElement in range(5): print(currentElement) print(\"I also belong to the loop block\") print(\"I don't belong to the loop block anymore\")","title":"Significant whitespace"},{"location":"implementation/remarks/#everything-is-an-object","text":"Everything. Even functions, classes, modules and files. Everything. In this Python Online Tutor example you can see how really, really everything in a running Python program is an object.","title":"Everything is an object"},{"location":"implementation/remarks/#passing-by-assignment","text":"Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se. -- How do I write a function with output parameters (call by reference)? The way passing data to functions work in Python is quite specific , so it is important that you are aware of it and understand it. Walk through this example in the tutor to visualise what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects. Changing the state of an object that is not returned explicitly is called a side effect . Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might lose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python.","title":"Passing by assignment"},{"location":"implementation/remarks/#magic-methods-protocols","text":"Those __something__() thingies might look scary for the uninitiated, but you will love them, once you have grasped the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations.","title":"Magic methods (protocols)"},{"location":"implementation/remarks/#object-representation-__repr__","text":"If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value -- Python docs In this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done correctly, this also works when using inheritance (see Stock and Waste ). This could also be useful: reprlib helps making better representations .","title":"Object representation (__repr__)"},{"location":"implementation/remarks/#make-your-own-objects-behave-like-built-in-data-types","text":"Let an object have a length ( __len__ ) and a concept of being True or False depending on having a length > 0 or not. Make an object iterable ( __iter__ ) .","title":"Make your own objects behave like built in data types"},{"location":"implementation/remarks/#other-uses-of-special-object-attributes","text":"All objects have a name ( __name__ ) The name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program: Set the name of the logger object to get information from where the log was written If a module is started directly it has the special name __main__ - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the canonic way to do this. More resources about magic methods Python docs A Guide to Python's Magic Methods (original site went down sadly)","title":"Other uses of special object attributes"},{"location":"implementation/remarks/#assertions","text":"What can be asserted without evidence can be dismissed without evidence. -- Christopher Hitchens To assert something means \"to state or express positively\". Assertions are regarded as important enough in Python that assert is a statement (since Python 3 even print is not important enough to be a statement). assert evaluates an expression and raises an AssertionError if the result of the evaluation is False (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is truthy if evaluated as bool . def spam(someObject): assert someObject, f\"Hey! {someObject} is not what I want!\" print(someObject) spam([1, 2]) spam([]) The assert in the spam function makes sure that the argument passed evaluates to True before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback. This is a good way to make sure that your program crashes early if the preconditions are not what you expect them. It's like making sure there is a chair there before you sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science. Look for uses of the assert statement in the code to get an idea how it might be used.","title":"Assertions"},{"location":"implementation/remarks/#logging","text":"Python has an easy-to-use and convenient logging module included. There is no reason why beginners shouldn't learn to use that right away. This is better than cluttering the code with calls to print . With logging you have the possibility to use different log levels and adjust the output when debugging problems. You can set the level to logging.DEBUG to see the full story or even disable it when running thousands of simulations, where logging would slow the program down. We use a simple format and the convenience function to initialise the logger to write to the terminal with a certain level.","title":"Logging"}]}